// based on cross-env but super stripped down, especially to use shell: true
import {spawn} from 'child_process';

const args = process.argv.slice(2);
const command = args.shift();

const proc = spawn(`${command} ${args.join(' ')}`, {
  stdio: 'inherit',
  env: {...process.env, NODE_OPTIONS: '-C typescript'},
  shell: true
});

process.on('SIGTERM', () => proc.kill('SIGTERM'))
process.on('SIGINT', () => proc.kill('SIGINT'))
process.on('SIGBREAK', () => proc.kill('SIGBREAK'))
process.on('SIGHUP', () => proc.kill('SIGHUP'))

proc.on('exit', (code, signal) => {
  let crossEnvExitCode = code;
  // exit code could be null when OS kills the process(out of memory, etc) or
  // due to node handling it but if the signal is SIGINT the user exited the
  // process so we want exit code 0
  if (crossEnvExitCode === null) {
    crossEnvExitCode = signal === 'SIGINT' ? 0 : 1;
  }
  process.exit(crossEnvExitCode)
});